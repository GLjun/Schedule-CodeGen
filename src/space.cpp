/*************************************************************************
	> File Name: space.cpp
	> Author: 
	> Mail: 
	> Created Time: Tue 21 May 2019 06:56:39 AM UTC
 ************************************************************************/

#include <vector>
#include "space.h"
#include "util.h"
#include "schedule.h"

namespace SC
{

/*void Space::define_split(Iter x, int min, int max)
{
    get()->splitspaces.emplace_back(SplitSpaceNode::make(std::move(x), min, max));
}

void Space::define_split(Iter x, const std::vector<int>& candidates)
{
    get()->splitspaces.emplace_back(
            SplitSpaceNode::make(std::move(x), 
                std::forward<const std::vector<int>&>(candidates)));
}

void Space::define_reorder(const std::vector<std::vector<Iter>>& candidates)
{
    get()->reorderspaces.emplace_back(candidates);
}

void Space::define_unroll(Iter x, const std::vector<int>& candidates)
{
    get()->unrollspaces.emplace_back(std::move(x), candidates);
}

void Space::define_split(Iter x, int min, int max)
{
    get()->splitspaces.emplace_back(SplitSpaceNode::make(std::move(x), min, max));
}*/


/*void Space::define_split(const std::string& tag, int min, int max)
{
    auto ret = get()->spaces.emplace(tag, SplitSpaceNode::make(Iter(), min, max));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
}
void Space::define_split(const std::string& tag, const std::vector<int>& candidates)
{
    auto ret = get()->spaces.emplace(tag, SplitSpaceNode::make(Iter(), candidates));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
}

void Space::define_reorder(const std::string& tag, const std::vector<std::vector<Iter>>& candidates)
{
    auto ret = get()->spaces.emplace(tag, ReorderSpaceNode::make(candidates));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
}
void Space::define_unroll(const std::string& tag, const std::vector<int>& candidates)
{
    auto ret = get()->spaces.emplace(tag, candidates);
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
}*/


AxisPair Space::define_split(const std::string& tag, Axis axis,  int min, int max)
{
    LOG("split");
    auto ret = get()->spaces.emplace(tag, SplitSpaceNode::make(axis, min, max));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
    auto ptr = ret.first->second.cast_to<SplitSpaceNode>();
    return {ptr->outer, ptr->inner};
}

AxisPair Space::define_split(const std::string& tag, Axis axis, const std::vector<int>& candidates)
{
    auto ret = get()->spaces.emplace(tag, SplitSpaceNode::make(axis, candidates));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
    auto ptr = ret.first->second.cast_to<SplitSpaceNode>();
    return {ptr->outer, ptr->inner};
}

void Space::define_reorder(const std::string& tag, const std::vector< std::vector<Axis> >& candidates)
{
    auto ret = get()->spaces.emplace(tag, ReorderSpaceNode::make(candidates));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
}

void Space::define_unroll(const std::string& tag, Axis axis, const std::vector<int>& candidates)
{
    auto ret = get()->spaces.emplace(tag, UnrollSpaceNode::make(axis, candidates));
    CHECK_IF(ret.second, "space tag %s exists", tag.c_str());
}

AxisPair SplitSpaceNode::apply_split(Stage& s)
{
    Iter io, ii;
    s.split(x->x, io, ii, candidates->next());

    outer->x = std::move(io);
    inner->x = std::move(ii);

    return {outer, inner};
}

void ReorderSpaceNode::apply_reorder(Stage& s)
{
    int r = candidates_indices->next();
    auto& ordered_axes = candidates[r];
    //check iters of axes are not null, i.e., the iters of axes has been set.
    //for example, if some axes is generated by split, they are placeholders at the beginning.
    //These placeholders need to be set.
    bool no_null_iter = true;
    for(auto& axis : ordered_axes)
        no_null_iter = no_null_iter && axis->x.notNull();
    CHECK_IF(no_null_iter, "some axes to be reordered are null!");

    std::vector<Iter> iters;
    for(auto& axis : ordered_axes)
        iters.push_back(axis->x);
    s.reorder(iters);
}

void UnrollSpaceNode::apply_unroll(Stage& s)
{ 
    CHECK_IF(false, "unroll has not been implemented");
}

AxisPair Space::apply_split(const std::string& tag, Stage& s)
{
    CHECK_IF(get()->spaces.count(tag), "no such space %s ", tag.c_str());
    auto& bs = (get()->spaces)[tag];
    CHECK_IF(bs.is_type<SplitSpaceNode>(), "space %s is not split space", tag.c_str());
    SplitSpaceNode* n = bs.cast_to<SplitSpaceNode>();
    /*Iter outer, inner;
    // n->x means the target axis to be splited
    // n->x->x means the iter of target axis
    s.split(n->x->x, outer, inner, n->candidates->next());
    n->outer->x = std::move(outer);
    n->inner->x = std::move(inner);
    return {n->outer, n->inner};*/
    return n->apply_split(s);
}

void Space::apply_reorder(const std::string& tag, Stage& s)
{
    CHECK_IF(get()->spaces.count(tag), "no such space %s ", tag.c_str());
    auto& bs = (get()->spaces)[tag];
    CHECK_IF(bs.is_type<ReorderSpaceNode>(), "space %s is not reorder space", tag.c_str());
    
    ReorderSpaceNode* n = bs.cast_to<ReorderSpaceNode>();
    n->apply_reorder(s);
}

void Space::apply_unroll(const std::string& tag, Stage& s)
{
    CHECK_IF(get()->spaces.count(tag), "no such space %s ", tag.c_str());
    auto& bs = (get()->spaces)[tag];
    CHECK_IF(bs.is_type<UnrollSpaceNode>(), "space %s is not unroll space", tag.c_str());

    UnrollSpaceNode* n = bs.cast_to<UnrollSpaceNode>();
    n->apply_unroll(s);
}

} // namespace SC
